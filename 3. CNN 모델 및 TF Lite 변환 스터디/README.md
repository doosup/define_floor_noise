## 3. CNN 모델 및 TF Lite 변환 스터디

### 3-1. **CNN 구조 스터디 및 발표 준비**

본 프로젝트 "TinyML을 이용한 층간소음 측정"에서의 활동 중 하나는 팀원들과 함께 딥러닝 모델의 핵심 구성 요소와 사용 방법에 대한 스터디였다. 특히, CNN(Convolutional Neural Network)은 이미지나 소리 데이터의 패턴을 효과적으로 파악하는 데 매우 유용한 모델로, 이에 대한 깊은 이해는 프로젝트의 핵심 기술 구현에 필수적이었다.

주요 활동 중 하나는 Tensorflow의 keras API를 활용한 딥러닝 모델 구축 방법에 대한 스터디였다. 이 과정에서 우리는 Dense Layer를 중심으로 모델을 구축하는 방법을 학습하였으며, 이 Layer는 복잡한 데이터 패턴을 학습하는 데 중요한 역할을 한다. 이를 통해 각 Layer의 기능, 파라미터 설정 방법, 결과 분석 방법에 대한 깊은 이해를 얻었다.

이어서 Tensorflow lite를 활용한 딥러닝 모델 변환과정 및 결과 공유에 집중하였다. 여기서는 작성된 모델을 MAKE 파일로 변환하고 실제 장치에서의 실행 프로세스를 구축하는 방법에 대해 학습했다. 특히 sine 파형 데이터를 사용한 모델 구현과 테스트에 성공했으며, 최신화된 코드와의 호환성 문제 해결을 위한 노력도 있었다.

이 활동을 통해 얻은 결과물로는 다음과 같은 것들이 있다:

1. Tensorflow의 keras API를 활용한 딥러닝 모델 구축 방법에 관한 자료 및 코드.
2. Tensorflow lite를 활용한 모델 변환과정 및 실행 프로세스에 관한 자료 및 코드.
3. 팀원들과의 협업을 통한 최신화 코드와 호환성 문제 해결 방안 문서.

프로젝트의 성공적인 진행을 위해 이러한 기술적인 내용의 습득과 공유는 매우 중요하다. 팀원들과의 협력을 바탕으로, 앞으로도 지속적인 연구와 발표를 통해 프로젝트의 완성도를 높여 나갈 것이 주된 목적이다.

근거 자료로서, CNN 구조의 핵심 코드를 분석한 내용의 일부를 첨부한다. 코드 내용이 방대하여, https://github.com/yunho0130/tensorflow-lite/blob/master/tensorflow/lite/micro/examples/magic_wand/train/train.py 링크를 통해 코드를 확인해 주시기 바란다.

```

1-14: 파일 저작권 및 라이센스에 대한 주석입니다.

16-18: 필요한 모듈들을 임포트합니다. argparse는 명령줄 파싱을 위한 것이고, datetime과 os는 시간 및 운영체제 관련 작업에 사용됩니다. 마지막으로, data_load에서 DataLoader 클래스를 임포트합니다.

20-23: TensorBoard 로깅을 위한 디렉토리와 콜백을 설정합니다.

25-28: reshape_function은 입력 데이터를 모델에 맞게 재구성하는 함수입니다.

30-34: calculate_model_size 함수는 모델의 크기를 계산하고 출력합니다.

36-51: build_cnn 함수는 합성곱 신경망(CNN)을 구축하고, 그 경로를 반환합니다.

53-59: build_lstm 함수는 LSTM(Long Short-Term Memory) 신경망을 구축하고, 그 경로를 반환합니다.

61-63: load_data 함수는 훈련, 검증, 테스트 데이터셋을 로드하고 포맷팅합니다.

65-70: build_net 함수에서 사용자가 선택한 CNN 또는 LSTM 중 하나의 네트워크를 구축합니다.

72-108 : train_net 함수에서 네트워크가 훈련되며 결과가 평가됩니다. 이 과정에서 TensorFlow Lite 형식으로 변환된 모델이 디스크에 저장됩니다.

110 - 126 : 메인 실행 부분으로서 명령 줄 인수로부터 입력받은 정보(모델 유형 및 개인별 분류 방법 여부 등), 해당 정보에 따라 데이터 로딩 및 네트워크 빌드 과정이 진행되며 마지막으로 네트워크의 훈련이 이루어집니다.

```

<br>

### 3-2. 딥러닝 모델 구축 및 학습

본 프로젝트 "TinyML을 이용한 층간소음 측정"의 진행 과정에서 딥러닝 모델의 구축 및 학습은 핵심적인 활동 중 하나로 판단되었다. 지난 활동을 통해 우리 팀은 필요한 기술 및 도구에 대한 깊은 이해를 바탕으로 모델 구축 및 학습을 진행했다.

활동에서는 데이터 수집 방법론에 대한 학습을 진행했다. 이를 통해 층간소음 데이터의 특성 및 필요한 전처리 과정에 대한 깊은 이해를 얻었다. 데이터의 특성을 분석하고, 이를 바탕으로 적합한 딥러닝 모델의 구조를 결정하는 논의가 이루어졌다. CNN과 Dense Layer를 조합하여 복잡한 패턴을 효과적으로 학습할 수 있는 모델을 설계했다.

이후, 아두이노와 같은 하드웨어 장치를 활용하여 데이터를 수집하고, 이를 모델에 입력으로 사용하는 방법에 대한 스터디를 진행했다. Tensorflow의 keras API를 활용한 모델 구축 및 학습 과정을 상세히 알아봤다. 모델을 Tensorflow lite를 통해 아두이노와 같은 임베디드 시스템에서 실행 가능한 형태로 변환하는 방법에 대한 학습 및 실습을 진행했다.

결과적으로, 본 활동을 통해 다음과 같은 결과물을 생성했다:

1. 층간소음 데이터를 효과적으로 학습할 수 있는 딥러닝 모델의 구조 및 학습 방법.

2. 실제 임베디드 시스템에서 실행 가능한 모델의 변환 및 최적화 방법.

3. 모델의 성능을 검증하는 다양한 테스트 및 평가 기법.

프로젝트의 성공적인 진행을 위해, 이러한 기술적인 내용의 습득 및 공유는 매우 중요하다. 앞으로의 활동에서도 지속적인 모델 개선 및 최적화 작업을 통해 프로젝트 목표를 성취할 것이 딥러닝 모델 구축 및 학습의 주된 목적이다.

이 활동에 대한 내용으로 딥러닝 모델 구축에 대한 핵심 내용들을 담은 create_model.zip 파일을 근거자료로 제출한다. 아래는 위 파일에 대한 내용 일부이다.

<img src="https://raw.githubusercontent.com/jaewonE/define_floor_noise/main/images/sine_plot_with_noise_split.png" alt="sine_plot_with_noise_split">

<br>

### 3-3. **Tensorflow Lite를 통한 변환 및 예측**

Tensorflow Lite를 중심으로 한 모델 변환 및 예측에 관한 핵심적인 내용을 상세히 살펴보았다.

초소형 머신러닝 TinyML의 12장 내용을 기반으로, 마술 지팡이 모델 학습에 대한 깊은 이해를 바탕으로 핵심 코드를 분석하였다. 분석된 코드 중 train.py는 모델의 학습 및 검증과정을 다루며, 특히 Tensorflow Lite 형식으로 모델 변환하는 부분이 포함되어 있다. 이를 통해, 우리 팀은 딥러닝 모델을 임베디드 시스템에서 실행 가능한 형태로 변환하는 방법에 대한 통찰을 얻을 수 있었다.

또한, train_magic_wand_model_kor.ipynb 코드를 통해 Jupyter Notebook 환경에서 모델 학습 및 변환 과정을 실시간으로 시각화하고, 모델의 성능을 평가하는 방법을 학습하였다. 특히, TensorBoard 확장 기능을 이용하여 학습 과정 중 모델의 성능 변화를 시각적으로 파악할 수 있게 되었다.

magic_wand_test.cc 코드는 TensorFlow Lite Micro에서 작동하는 Magic Wand 모델을 테스트하기 위한 코드로, 이를 통해 우리 팀은 임베디드 환경에서의 모델 추론 과정 및 성능 평가 방법에 대한 깊은 이해를 얻을 수 있었다.

가속도계 센서를 통한 데이터 수집 및 실시간 시각화는 프로젝트의 핵심 요소 중 하나이다. 이를 위해 아두이노 기반의 코드를 성공적으로 구현하였으며, 이를 바탕으로 층간소음 데이터를 정밀하게 수집할 예정이다.

결과적으로, 6주차 활동을 통해 다음과 같은 성과를 얻었다:

1. Tensorflow Lite를 사용하여 딥러닝 모델을 임베디드 시스템에서 실행 가능한 형태로 변환하는 방법에 대한 깊은 이해.

2. 아두이노와 가속도계 센서를 활용한 층간소음 데이터의 실시간 수집 및 시각화 기법의 구현.

3. 여러 코드의 분석을 바탕으로, 모델의 학습, 변환, 평가에 필요한 기술적 능력의 향상.

이 활동에 대한 근거 자료로 각 코드에 대한 설명 하나하나를 자세히 풀이하며 분석한 ‘hello_world_test.cc’ 파일을 제출한다. 이래는 제출된 파일 코드의 일부로 다음과 같이 구성되어 있다.

```cpp
// RegisterOps 함수: HelloWorldOpResolver 인스턴스에 연산자를 등록합니다.

// 인자: op_resolver: HelloWorldOpResolver 타입의 참조, 연산자를 등록할 대상입니다.

// 반환값: kTfLiteOk: 연산자 등록이 성공적으로 완료되었음을 나타냅니다.

TfLiteStatus RegisterOps(HelloWorldOpResolver &op_resolver) {

  // op_resolver에 완전 연결 레이어(Fully Connected Layer) 연산자를 등록합니다.

  // AddFullyConnected(): 완전 연결 레이어 연산자를 등록하는 메서드입니다.

  TF_LITE_ENSURE_STATUS(op_resolver.AddFullyConnected());

  return kTfLiteOk; // 연산자 등록 성공을 나타내는 상수를 반환합니다.

} // RegisterOps 함수 종료

```
